---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Prediction and maps

In this chapter we predict from the fitted model and produce final SDMs maps.

First we load a list of required libraries.
```{r, eval=T,message=FALSE,warning=FALSE}
requiredPackages <- c(
  #GENERAL USE LIBRARIES --------#
  "here", # Library for reproducible workflow
  "rstudioapi",  # Library for reproducible workflow
  "ggplot2", #for plotting
  "tidyverse", 
  "rgdal", # to work with Spatial data
  "raster", #spatial 
  "maps", #world map
  "maptools", #plotting world map
  "RColorBrewer", #color palette
  "scam" #sdm models under the ecological niche theory framework
  )
```

We run a function to install the required packages that are not in our system and load all the required packages.
```{r, eval=T,message=FALSE,warning=FALSE}
install_load_function <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg))
    install.packages(new.pkg, dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}

install_load_function(requiredPackages)

```

We define some overall settings.
```{r, eval=T,message=FALSE,warning=FALSE}
# Location of script
setwd(dirname(getSourceEditorContext()$path))

# General settings for ggplot (black-white background, larger base_size)
theme_set(theme_bw(base_size = 16))
```

## Prepare environmental data. 

In previous steps (see Chapter 2), we have defined the study area that defines the extent of our spatial data. We load the `area` object that is a SpatialPolygonsDataFrame class:
```{r, eval=T, warning=F, message=F}
load("data/spatial/area.RData")
```

And we load the rasterStack with the downloaded environmental data.
```{r}
load("data/env/myBioracle.layers.Rdata")
```

We transform the environmental data set first into a data frame, and then into a SpatialDataFrame.
```{r, eval=F}
myBioracle.layers<-stack("data/env/myBioracle.layers.tif")
env_dataframe <- raster::as.data.frame(myBioracle.layers, xy=TRUE)
pts <- env_dataframe[,c("x","y")]

coordinates(pts) <- ~ x + y
proj4string(pts) <-proj4string(area)
```

```{r, eval=F}
  
## Select only our study area data in the defined previously selected area
env_dataframe <- data.frame(subset(env_dataframe, !is.na(over(pts, area)[,1])))
```

```{r, eval=F}

#save the data frame
save(env_dataframe, file="data/env/env_dataframe.Rdata")
```

## Projection
```{r, eval=F}
#load PA data
load(file.path ("data", "outputs_for_modelling", "PAdata_with_env.Rdata"))

#Load raster stack containing all variables
load("data/env/env_dataframe.Rdata")

#remove positive bathy
env_dataframe_proj<-subset(env_dataframe,BO_bathymean<0)

#Load SC-GAM model

load(file.path("models", "model.Rdata"))

# predicting 
predict <- predict(selected_model,newdata=env_dataframe_proj,type ="response",se.fit=T)         
env_dataframe_proj$fit<-predict$fit
env_dataframe_proj$se.fit<-predict$se.fit

save(env_dataframe_proj, file="results/projection.Rdata")
```


## Mapping

```{r, eval=F}
p<-ggplot()+
  geom_raster(data=subset(env_dataframe_proj),aes(x,y,fill=fit))+scale_fill_gradient2(low="blue", mid="orange",high="red",midpoint = 0.5) +
  ggtitle("with bathy concave")+ geom_point(data=subset(data,occurrenceStatus==1),aes(LON,LAT),col=1,size=0.3)     

print(p)

ggsave(file.path("plots","projections",paste0("proj_map.png")), p, device="png")



```

